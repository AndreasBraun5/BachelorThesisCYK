% !TeX spellcheck = en_GB

\section{Algorithms}\label{algorithms}

\noindent Does the output $P \subseteq V \times (V^{2} \cup \Sigma)$ imply that $G$ is in CNF? CNF does only have useful variables [TI script Def. 8.3 page 210] vs. $P \subseteq V \times (V^{2} \cup \Sigma)$.\\
\noindent More of a problem is that the set $P$ is not necessarily in CNF. It is possible that there are unreachable variables -- from the starting variable.

\subsection{Algorithm sub modules}
Sub modules are parts of the algorithms that are denoted with \circled{A}, \circled{B}, ... . They are noteworthy procedures that need to be explained in more detail for a better understanding of the way of working of the algorithms.
\subsubsection{Distribute A \& B}
\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{Distribute}
		\label{Distribute}
		\SetAlgoLined
		\KwIn{ $Rhse \subseteq\ (V^{2} \cup \Sigma),\ V$}
		\KwOut{Set of productions $P$}
		$i \in  \mathbb{N},\ j \in  \mathbb{N}$\;
		\ForEach{$rhse \in Rhse$}{
			$choose\ n\ uniform\ randomly\ in\ [i, j]$\;
			$V_{add} := uniform\ random\ subset\ of\ size\ n\ from\ V$\;
			$P = P \cup \{ (v, rhse)\ |\ v \in V_{add},\ rhse \in Rhse \} $\;	
		}
		\Return $P$;
	\end{algorithm}
}
Algorithm \ref{Distribute} isn't needed anymore for the descriptions of the basic idea of the algorithm. It will be a module later on while tweaking the algorithms.

\subsubsection{Stopping Criteria C}
It is fulfilled if more than half of the pyramid cell are not empty. This is an independent criteria.

Stop if any variable is in the tip cell of the pyramid. This is dependent on the count of different available variables. 

\subsubsection{ChooseXYDependingOnIFromRowSet D}
$RowSet \subseteq \{(XY,i)\ |\ X,Y \in V \wedge i \in \mathbb{N} \}$\\
Compression of the RowSet like: (AB,3) and (AB,1) -> (AB,1) --> RowSetCompressed\\
rowListWeighted = add i times XY to rowListWeighted.

\pagebreak
\subsection{DiceRollOnly}
\subsubsection{Basic Idea}
\noindent This is a very naive way of generating grammars, which will be the starting point for our algorithms to be found. Each future algorithm must have a higher score than this algorithm or otherwise it would be worse, than simple dice rolling the distribution of terminals and compound variables with removing the not contributing productions afterwards.
\subsubsection{Algorithm}

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{DiceRollOnly}
		\label{DiceRollOnly}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$ }
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$P = Distribute(\Sigma,\ V)$;  \circled{A}\\
		$P = P \cup Distribute(V^2,\ V)$;  \circled{B}\\
		$Pyramid = CYK(G,\ w)$\;	
		$P = DeleteUnneccessaryRules(P, w, Pyramid)$\; \label{contributing}	
		\Return $P$\;
		\footnotetext{ 
			Line \ref{contributing}: ?Removes all production that don't contribute, but unreachable productions still possible.? $Contributing$ production iff $useful$ i.e. it appears in some derivation of some terminal string from the start symbol AND $producing$ i.e. it is needed for this parsing table.
		}
	\end{algorithm}
}
As seen in table \ref{DiceRollOnlySR} the algorithm shows a relatively low success rate for producibility.

\noindent This can be explained with ... . 

\noindent Something about what can be improved in another attempt or the next attempt. 
\pagebreak


\subsection{BottomUpDiceRollVar1}
\subsubsection{Basic Idea} 
This algorithm uses the Bottom-Up approach where the parsing table is filled starting from the leaves. An extension compared to algorithm \ref{DiceRollOnly} is that productions are only added as long as the the stopping criteria isn't met.
\subsubsection{Algorithm}

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{BottomUpDiceRollVar1}
		\label{BottomUpDiceRollVar1}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$ }
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$P = Distribute(\Sigma,\ V)$;  \circled{A}\\
		$Pyramid = CYK(G,\ w)$\label{stepii}\;
		\For{$i:=1\ \textbf{to}\ i_{max}$}{
			$J = \{0,~...~,~j_{max} -1\}$;~~\tcp{$J \subseteq \mathbb{N}$}
			$CellSet = \emptyset$;~~\tcp{$CellSet \subseteq V^2$}
			\While{$|J|>0$}{
				$choose\ one\ j \in J\ uniform\ randomly$\label{chooseJ}\;
				$J = J \setminus \{j\} $\;
				$CellSet = CalculateSubsetForCell(Pyramid,\ i,\ j)$\;
				$P = P \cup Distribute(CellSet,\ V)$;  \circled{B}\\
				$Pyramid = CYK(G,\ w)$\;
				$P = DeleteUnneccessaryRules(P, w, Pyramid)$\; \label{contributing}	
				\If{$stopping\ criteria~met$~\circled{C}}{
					\Return $P$\;
				}
			}
		}
		\Return $P$\;
		\footnotetext{
			\noindent Line \ref{stepii}: Fills the i=0 row of the pyramid.
			
			\noindent Line \ref{chooseJ}: A cell is only visited only once.
			
			\noindent Note: Maybe modify algorithm to also work with the threshold.
		}
	\end{algorithm}
}




A relatively small number of productions is already sufficient to completely fill the parsing table. This can be seen if one does take look at the log-file where the final cell that has been worked with is denoted.
A good chosen stopping criteria allows a higher success rate.

\pagebreak
\subsection{BottomUpDiceRollVar2}
\subsubsection{Basic Idea} 
As seen in algorithm \ref{BottomUpDiceRollVar1} a small number of productions is sufficient to make the parsing table quite full. If an cell is nearer to the leaves its chance to be in the set of one of the calculated sub sets for a cell is higher. Therefore you could introduce a bias that favours cells with an higher index i to allow different cell combinations.

Berechnung von RowSet für alles Restlichen Zellen in der Zeile!!!!!?????????!!!!!!!
Bisher nur für alle bisher Verwendeten.

\subsubsection{Algorithm}

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{BottomUpDiceRollVar2}
		\label{BottomUpDiceRollVar2}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$ }
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$RowSet = \emptyset$;~~\tcp{$RowSet \subseteq \{(XY,i)\ |\ X,Y \in V \wedge i \in \mathbb{N} \}$}
		$P = Distribute(\Sigma,\ V)$;  \circled{A}\\
		$Pyramid = CYK(G,\ w)$ \label{stepii}\;
		\For{$i:=1\ \textbf{to}\ i_{max}$}{
			%$choose\ j\ uniform\ randomly\ in\ [0,\ j_{max}-i]  $\;
			\For{$j:=0\ \textbf{to}\ j_{max}-i$}{
				$RowSet = RowSet \cup \{(XY,i)\ |\ XY \in CalculateSubsetForCell(Pyramid,\ i,\ j) \}$\label{rowSet}\;
			}
			\While{$threshold_i\ not\ reached $}{ \label{threshold}
				$choose\ one~xy\ out\ of\ (XY,\ i) \in RowSet~uniform\ randomly\ with$ $probability~depending~on~i $;\label{chooseVc} \circled{D}  \\
				$P = P \cup Distribute(xy,\ V) $; \circled{B}  \\
				$Pyramid = CYK(G,\ w)$\;
				$P = DeleteUnneccessaryRules(P, w, Pyramid)$\; \label{contributing}	
				\If{$stopping\ criteria~met$~\circled{C}}{
					\Return $P$\;
				}	
			}
		}
		\Return $P$\;
		\footnotetext{
			\noindent Line \ref{stepii}: Fills the i=0 row of the pyramid.
			
			\noindent Line \ref{rowSet}: $(AB,1), (AB,2), (BC,3) ... \in sub$ $\rightarrow$ multiple occurrences of $AB$ are allowed here yet.
			
			\noindent Note Line \ref{threshold}: threshold is reached iff more than half of the cells of one row aren't empty.
		}
	\end{algorithm}
}



\pagebreak
\subsection{SplitThenFill (Idea 1)}
\subsubsection{Basic Idea} 
The basic idea for this algorithm is to uniform randomly generate a predefined structure of the derivation tree that helps adding the "right" productions. You always update the pyramid after adding one production to the grammar.
This is also some kind of BottumUp approach - Bottom Up: The parse table is filled relatively evenly. All information regarding the upper cells are available and can be used. Similar to the CYK Algorithm approach. \\
It is important to distribute the varComp exactly to one var.
\subsubsection{Algorithm}
\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{SplitThenFillPrep}
		\label{SplitThenFillPrep}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$}
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$P = Distribute(\Sigma,\ V)$; \circled{A} \label{stepii}  \\		
		$Sol = (P_{Sol},~Cell_{i,j})$;~~\tcp{$P_{Sol} \subseteq P~\wedge~ Cell_{i,j} \in Pyramid$} \label{cell}
		$Sol = SplitThenFill(P,\ w,\ i_{max},\ 0)$\;
		\Return $P_{Sol}$\;
		\footnotetext{
			\noindent Line \ref{stepii}: Fills the i=0 row of the pyramid.	
		}
	\end{algorithm}
}
\\

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{SplitThenFill}
		\label{SplitThenFill}
		\SetAlgoLined
		\KwIn{$P \subseteq V \times (V^{2} \cup \Sigma),\ w \in \Sigma^{*},\ i,j \in \mathbb{N}$ }
		\KwOut{$(P,~Cell_{i,j})$}
		\If{$i=0$}{
			\Return $(P,\ Cell_{i,j})$\label{row0}\;
		}	
		$choose\ one\ m\ uniform\ randomly\ in\ [j+1,\ j+i]$\;
		$(P,\ Cell_l) = SplitThenFill(P,\ w,\ (m-j-1),\ j)$\label{left}\;
		$(P,\ Cell_r) = SplitThenFill(P,\ w,\ (j+i-m),\ m)$\label{right}\;
		$Pyramid = CYK(G,\ w)$\label{cyk}\;
		\If{$stopping\ criteria~met$~\circled{C}}{
			\Return $(P,\ Cell_{i,j})$\;
		}
		\If{$Cell_{i,j} = \emptyset$}{
			$Vc = uniform\ random\ subset\ from\ \{vc\ |\ v \in Cell_l\ \wedge\ c \in Cell_r\} ~with~|Vc| \geq 1$\;
			$P = P \cup Distribute(Vc,\ V) $; \circled{B}  \\
		}
		
		\Return $(P,\ Cell_{i,j})$\;
		\footnotetext{
		}
	\end{algorithm}
}

\noindent The stopping criteria is met if the tip of the pyramid is not empty. It is a valid approach because if this cell is not empty it means that there is a chance of being able to generate the word. To add further productions only results in a grammar that has to many productions with its pyramid having to many variables.
\pagebreak

\subsection{SplitAndFill}
\subsubsection{Basic Idea} 
It is dependent on the length of the word.\\
It is important that the terminals and the varcomps are distributed to exactly one var.
The stopping criteria will be that each cell with index i = 0 must be not empty.
Now there is a second option to fill the parse table:
\begin{enumerate}
	\item Top Down: The parse table is filled quiet unevenly. You don't have all information available. Think about adding a production for the node cell: You can add a production so that its producing cells fill the node cell, but you don't know what actually would be the best to fill in these producing cells because they themselves aren't looked at yet. This problem is kept until the last depth of the recursion, where the cells in row $i=0$ are taken into account. Only starting there you know what variables actually produce the terminals.\\
	Maybe solution: For the Top Down approach, don't assume that the terminals are already distributed over the V. Distribute the terminals over the variables in an ideal way that fits your already generated productions best.
\end{enumerate}
The problem is that we have as much productions as splits in the derivation tree exist. The productions count can be reduced via merging duplicate productions and via reducing the split count in the tree. \\
Merging productions means: If there are A --> BS and C --> BS then only one Production of these two can remain.\\
Reducing the split count in the tree is equal to generate a tree with minimal size. Minimal size is achieved via splitting the tree most evenly always.
\subsubsection{Algorithm}
\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{SplitAndFillPrep}
		\label{SplitAndFillPrep}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$}
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$Sol = (P_{Sol},~v)$;~~\tcp{$P_{Sol} \subseteq P$} \label{cell}
		$Sol = SplitAndFill(P,\ w,\ i_{max},\ 0)$\;
		$Merge~productions~with~the~same~variableCompound~in~P_{Sol}$\;
		\Return $P_{Sol}$\;
		\footnotetext{
		}
	\end{algorithm}
}

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{SplitAndFill}
		\label{SplitAndFill}
		\SetAlgoLined
		\KwIn{$P \subseteq V \times (V^{2} \cup \Sigma),\ w \in \Sigma^{*},\ i,j \in \mathbb{N}$ }
		\KwOut{$(P,~v)$}
		\If{$i=0$}{
			\If{$terminal~w_j~not~already~distributed$}{
				$P = Distribute(w_j,\ V)$; \circled{A} \label{stepii}  \\		
			}
			\Return $(P,\ v_{lhse})$\;
		}
		$choose\ one\ m\ uniform\ randomly\ in\ [j+1,\ j+i]$\;
		$(P,\ v_l) = SplitThenFill(P,\ w,\ (m-j-1),\ j)$\label{left}\;
		$(P,\ v_r) = SplitThenFill(P,\ w,\ (j+i-m),\ m)$\label{right}\;	
		\If{$i=i_{max}$}{
			$P = P \cup (S,~v_l v_r)$\;
			\Return $(P,\ v)$\;
		}
		$P = P \cup (v,~v_l v_r)$\;
		\Return $(P,\ v)$\;
		\footnotetext{
		}
	\end{algorithm}
}
\\


\pagebreak
\subsection{Comparision of Algorithms}

\begin{table}[H]
	\centering
	\begin{tabular}{ | l | c |c |c |c | }
		\hline
Algorithm 		& SR 	& SRP 	& SRG 	& SRWP   	\\ \hline
\hline
DiceRollOnly 	& 09~\%	& 24~\% & 87~\% & 53~\%		\\ \hline
BotomUpVar1 	& 18~\% & 52~\% & 88~\% & 48~\% 	\\ \hline
BotomUpVar2 	& 22~\% & 46~\% & 93~\% & 62~\% 	\\ \hline
SplitThenFill 	& 28~\% & 39~\% & 97~\% & 80~\% 	\\ \hline
SplitAndFill 	& 16~\% & 100~\% & 99~\% & 16~\% 	\\ \hline
	\end{tabular}
	\caption{Comparison of the success rates of the algorithms}
	\label{comparisonAlgorithms}
\end{table}
Finding of ideal parameter for each algorithm.
\pagebreak