% !TeX spellcheck = en_GB

\section{Algorithms}\label{algorithms}
\subsection{Sub modules}
Sub modules are parts of the algorithms that are denoted circled like \circled{A}, \circled{B}, \circled{C} and \circled{D}. They are procedures that should to be explained in more detail a little bit for a better understanding of the way of working of the algorithms.\\

\noindent \textbf{Distribute$(\Sigma,\ V) $\circled{A} and Distribute$(V^2,\ V)$\circled{B}:}\\
The difference between \circled{A} and \circled{B} is that one time $\Sigma$ and the other time $V^2$ are distributed. The specifics of how they are distributed are the same in both cases as described in the following algorithm:\\

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{Distribute}
		\label{Distribute}
		\SetAlgoLined
		\KwIn{ $Rhse \subseteq\ (V^{2} \cup \Sigma),\ V$}
		\KwOut{Set of productions $P$}
		\ForEach{$rhse \in Rhse$}{
			$choose\ n\ uniform\ randomly\ in\ [i, j]$;~~\tcp{$i \in  \mathbb{N},\ j \in  \mathbb{N}$}
			$V_{add} := uniform\ random\ subset\ of\ size\ n\ from\ V$\;
			$P \cup \{ (v, rhse)\ |\ v \in V_{add},\ rhse \in Rhse \} $\;	
		}
		\Return $P$;
	\end{algorithm}
} \\

\noindent \textbf{Stopping Criteria \circled{C}:}\\
Two kinds of \circled{C} have been used. One is that it is true iff more than half of the pyramid cells are not empty and the other one is that there is at least one variable in the tip of the pyramid. It is to be taken in consideration that the latter is somewhat dependent on the count possible variables as seen in [XXX]. \\

\noindent \textbf{ChooseXYDependingOnIFromRowSet \circled{D}:}\\
$RowSet \subseteq \{(XY,i)\ |\ X,Y \in V \wedge i \in \mathbb{N} \}$\\
Compression of the RowSet like: (AB,3) and (AB,1) -> (AB,1) --> RowSetCompressed\\
rowListWeighted = add i times XY to rowListWeighted. XXX

\pagebreak
\subsection{DiceRollOnlyCYK}
\noindent This is a naive way of generating grammars, which will be the lower boundary while comparing the algorithms. Each future algorithm should have a higher score than this algorithm or otherwise it would be worse, than simple dice rolling the distribution of terminals \circled{A} and compound variables \circled{B}. \\

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{DiceRollOnlyCYK}
		\label{DiceRollOnlyCYK}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$ }
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$P = Distribute(\Sigma,\ V)$;  \circled{A}\\
		$P \cup Distribute(V^2,\ V)$;  \circled{B}\\
		$Pyramid = CYK(G,\ w)$\;	
		\Return $P$\;
	\end{algorithm}
}\\
\pagebreak


\subsection{BottomUpDiceRollVar1}
This algorithm uses the Bottom-Up approach (Chapter \ref{approaches}) whereby the parsing table is filled starting from the leaves in direction to the root node.\\

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{BottomUpDiceRollVar1}
		\label{BottomUpDiceRollVar1}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$ }
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$P = Distribute(\Sigma,\ V)$;  \circled{A}\\
		$Pyramid = CYK(G,\ w)$\label{stepii}\;
		\For{$i:=1\ \textbf{to}\ i_{max}$}{
			$J = \{0,~...~,~j_{max} -1\}$;~~\tcp{$J \subseteq \mathbb{N}$}
			$CellSet = \emptyset$;~~\tcp{$CellSet \subseteq V^2$}
			\While{$|J|>0$}{
				$choose\ one\ j \in J\ uniform\ randomly$\label{chooseJ}\;
				$J = J \setminus \{j\} $\;
				$CellSet = CalculateSubsetForCell(Pyramid,\ i,\ j)$\;
				$P \cup Distribute(CellSet,\ V)$;  \circled{B}\\
				$Pyramid = CYK(G,\ w)$\;	
				\If{$stopping\ criteria~met$~\circled{C}}{
					\Return $P$\;
				}
			}
		}
		\Return $P$\;
		\footnotetext{
			\noindent Line \ref{stepii}: Fills the i=0 row of the pyramid.
			
			\noindent Line \ref{chooseJ}: A cell is only visited only once.
		}
	\end{algorithm}
}
\noindent While taking a short look at the SRs in Table \ref{ComparisonOfAlgorithms} it is seen that the SR-Pyramid is a little bit lower compared to Algorithm \ref{DiceRollOnlyCYK}. Further investigation of the logs shows that a relatively small number of rules is already sufficient to invoke the stopping criteria \circled{C}. 

A good chosen stopping criteria allows a higher success rate.

\pagebreak
\subsection{BottomUpDiceRollVar2}

As seen in algorithm \ref{BottomUpDiceRollVar1} a small number of productions is sufficient to make the parsing table quite full. If an cell is nearer to the leaves its chance to be in the set of one of the calculated sub sets for a cell is higher. Therefore you could introduce a bias that favours cells with an higher index i to allow different cell combinations. \\

Berechnung von RowSet für alles Restlichen Zellen in der Zeile!!!!!?????????!!!!!!!
Bisher nur für alle bisher Verwendeten.\\



\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{BottomUpDiceRollVar2}
		\label{BottomUpDiceRollVar2}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$ }
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$RowSet = \emptyset$;~~\tcp{$RowSet \subseteq \{(XY,i)\ |\ X,Y \in V \wedge i \in \mathbb{N} \}$}
		$P = Distribute(\Sigma,\ V)$;  \circled{A}\\
		$Pyramid = CYK(G,\ w)$ \label{stepii}\;
		\For{$i:=1\ \textbf{to}\ i_{max}$}{
			%$choose\ j\ uniform\ randomly\ in\ [0,\ j_{max}-i]  $\;
			\For{$j:=0\ \textbf{to}\ j_{max}-i$}{
				$RowSet \cup \{(XY,i)\ |\ XY \in CalculateSubsetForCell(Pyramid,\ i,\ j) \}$\label{rowSet}\;
			}
			\While{$threshold_i\ not\ reached $}{ \label{threshold}
				$choose\ one~xy\ out\ of\ (XY,\ i) \in RowSet~uniform\ randomly\ with$ $probability~depending~on~i $;\label{chooseVc} \circled{D}  \\
				$P \cup Distribute(xy,\ V) $; \circled{B}  \\
				$Pyramid = CYK(G,\ w)$\;
				\If{$stopping\ criteria~met$~\circled{C}}{
					\Return $P$\;
				}	
			}
		}
		\Return $P$\;
		\footnotetext{
			\noindent Line \ref{stepii}: Fills the i=0 row of the pyramid.
			
			\noindent Line \ref{rowSet}: $(AB,1), (AB,2), (BC,3) ... \in sub$ $\rightarrow$ multiple occurrences of $AB$ are allowed here yet.
			
			\noindent Note Line \ref{threshold}: threshold is reached iff more than half of the cells of one row aren't empty.
		}
	\end{algorithm}
}



\pagebreak
\subsection{SplitThenFill}

The basic idea for this algorithm is to uniform randomly generate a predefined structure of the derivation tree that helps adding the "right" productions. You always update the pyramid after adding one production to the grammar.
This is also some kind of BottumUp approach - Bottom Up: The parse table is filled relatively evenly. All information regarding the upper cells are available and can be used. Similar to the CYK Algorithm approach. \\
It is important to distribute the varComp exactly to one var.

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{SplitThenFillPrep}
		\label{SplitThenFillPrep}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$}
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$P = Distribute(\Sigma,\ V)$; \circled{A} \label{stepii}  \\		
		$Sol = (P_{Sol},~Cell_{i,j})$;~~\tcp{$P_{Sol} \subseteq P~\wedge~ Cell_{i,j} \in Pyramid$} \label{cell}
		$Sol = SplitThenFill(P,\ w,\ i_{max},\ 0)$\;
		\Return $P_{Sol}$\;
		\footnotetext{
			\noindent Line \ref{stepii}: Fills the i=0 row of the pyramid.	
		}
	\end{algorithm}
}
\\

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{SplitThenFill}
		\label{SplitThenFill}
		\SetAlgoLined
		\KwIn{$P_{in} \subseteq V \times (V^{2} \cup \Sigma),\ w \in \Sigma^{*},\ i,j \in \mathbb{N}$ }
		\KwOut{$(P,~Cell_{i,j})$}
		$P =  P_{in}$\;
		\If{$i=0$}{
			\Return $(P,\ Cell_{i,j})$\label{row0}\;
		}	
		$choose\ one\ m\ uniform\ randomly\ in\ [j+1,\ j+i]$\;
		$(P,\ Cell_l) = SplitThenFill(P,\ w,\ (m-j-1),\ j)$\label{left}\;
		$(P,\ Cell_r) = SplitThenFill(P,\ w,\ (j+i-m),\ m)$\label{right}\;
		$Pyramid = CYK(G,\ w)$\label{cyk}\;
		\If{$stopping\ criteria~met$~\circled{C}}{
			\Return $(P,\ Cell_{i,j})$\;
		}
		\If{$Cell_{i,j} = \emptyset$}{
			$Vc = uniform\ random\ subset\ from\ \{vc\ |\ v \in Cell_l\ \wedge\ c \in Cell_r\} ~with~|Vc| \geq 1$\;
			$P \cup Distribute(Vc,\ V) $; \circled{B}  \\
		}
		
		\Return $(P,\ Cell_{i,j})$\;
		\footnotetext{
		}
	\end{algorithm}
}

\noindent The stopping criteria is met if the tip of the pyramid is not empty. It is a valid approach because if this cell is not empty it means that there is a chance of being able to generate the word. To add further productions only results in a grammar that has to many productions with its pyramid having to many variables.
\pagebreak

\subsection{SplitAndFill}

It is dependent on the length of the word.\\
It is important that the terminals and the varcomps are distributed to exactly one var.
The stopping criteria will be that each cell with index i = 0 must be not empty.
Now there is a second option to fill the parse table:
\begin{enumerate}
	\item Top Down: The parse table is filled quiet unevenly. You don't have all information available. Think about adding a production for the node cell: You can add a production so that its producing cells fill the node cell, but you don't know what actually would be the best to fill in these producing cells because they themselves aren't looked at yet. This problem is kept until the last depth of the recursion, where the cells in row $i=0$ are taken into account. Only starting there you know what variables actually produce the terminals.\\
	Maybe solution: For the Top Down approach, don't assume that the terminals are already distributed over the V. Distribute the terminals over the variables in an ideal way that fits your already generated productions best.
\end{enumerate}
The problem is that we have as much productions as splits in the derivation tree exist. The productions count can be reduced via merging duplicate productions and via reducing the split count in the tree. \\
Merging productions means: If there are A --> BS and C --> BS then only one Production of these two can remain.\\

\pagebreak
\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{SplitAndFillPrep}
		\label{SplitAndFillPrep}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$}
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$Sol = (P_{Sol},~v)$;~~\tcp{$P_{Sol} \subseteq P$} \label{cell}
		$Sol = SplitAndFill(P,\ w,\ i_{max},\ 0)$\;
		$Merge~productions~with~the~same~variableCompound~in~P_{Sol}$\;
		\Return $P_{Sol}$\;
		\footnotetext{
		}
	\end{algorithm}
}

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{SplitAndFill}
		\label{SplitAndFill}
		\SetAlgoLined
		\KwIn{$P_{in} \subseteq V \times (V^{2} \cup \Sigma),\ w \in \Sigma^{*},\ i,j \in \mathbb{N}$ }
		\KwOut{$(P,~v)$}
		$P = P_{in}$\;
		\If{$i=0$}{
			\Return $(P \cup (v,~ w_j),\ v_{lhse})$\;
		}
		$choose\ one\ m\ uniform\ randomly\ in\ [j+1,\ j+i]$\;
		$(P,\ v_l) = SplitAndFill(P,\ w,\ (m-j-1),\ j)$\label{left}\;
		$(P,\ v_r) = SplitAndFill(P,\ w,\ (j+i-m),\ m)$\label{right}\;	
		\If{$i=i_{max}$}{
			\Return $(P \cup (S,~v_l v_r),\ v)$\;
		}
		\Return $(P \cup (v,~v_l v_r),\ v)$\;
		\footnotetext{
		}
	\end{algorithm}
}
\\


\pagebreak
\subsection{Comparision of Algorithms} \label{ComparisonOfAlgorithms}
\noindent Write about the standard configuration used.
\begin{table}[H]
	\centering
	\begin{tabular}{ | l | c |c |c |c | }
		\hline
Algorithm 		& SR 	& SR-Producibility 	& SR-Cardinality-Rules 	& SR-Pyramid   	\\ \hline
\hline
DiceRollOnly 	& 09~\%	& 24~\% & 88~\% & 39~\%		\\ \hline
BotomUpVar1 	& 16~\% & 52~\% & 90~\% & 41~\% 	\\ \hline
BotomUpVar2 	& 19~\% & 47~\% & 93~\% & 53~\% 	\\ \hline
SplitThenFill 	& 24~\% & 40~\% & 97~\% & 67~\% 	\\ \hline
SplitAndFill 	& 11~\% & 100~\% & 69~\% & 15~\% 	\\ \hline
	\end{tabular}
	\caption{Comparison of the SRs of the algorithms. Stopping criteria root not empty.}
	\label{comparisonAlgorithms}
\end{table}
Finding of ideal parameter for each algorithm.

\begin{table}[H]
	\centering
	\begin{tabular}{ | l | c |c |c |c | }
		\hline
		Algorithm 		& SR 	& SR-Producibility 	& SR-Cardinality-Rules 	& SR-Pyramid   	\\ \hline
		\hline
		DiceRollOnly 	& 09~\%	& 23~\% & 88~\% & 38~\%		\\ \hline
		BotomUpVar1 	& 11~\% & 30~\% & 99~\% & 58~\% 	\\ \hline
		BotomUpVar2 	& 13~\% & 26~\% & 99~\% & 66~\% 	\\ \hline
		SplitThenFill 	& 24~\% & 40~\% & 97~\% & 67~\% 	\\ \hline
		SplitAndFill 	& 11~\% & 100~\% & 70~\% & 14~\% 	\\ \hline
	\end{tabular}
	\caption{Comparison of the SRs of the algorithms. Stopping criteria more than half.}
	\label{comparisonAlgorithms}
\end{table}



\begin{table}[]
	\centering
	\caption{My caption}
	\label{my-label}
	\begin{tabular}{l|c|c|c|c|c|c|c|}
		\cline{5-8}
		\multicolumn{4}{c|}{}                                                                                                                                                 & \multicolumn{4}{c|}{Pyramid}                                                                                                                                                        \\ \cline{1-4} \cline{6-8} 
		\multicolumn{1}{|l|}{Algorithm}     & SR   & \begin{tabular}[c]{@{}c@{}}Produci-\\ bility\end{tabular} & \begin{tabular}[c]{@{}c@{}}Cardinality-\\ Rules\end{tabular} &      & \begin{tabular}[c]{@{}c@{}}Force-\\ Right\end{tabular} & \begin{tabular}[c]{@{}c@{}}Vars-\\ PerCell\end{tabular} & \begin{tabular}[c]{@{}c@{}}VarsIn-\\ Pyramid\end{tabular} \\ \hline
		\multicolumn{1}{|l|}{DiceRollOnly}  & 09\% &                                                           &                                                              & 67\% &                                                        &                                                         &                                                           \\ \hline
		\multicolumn{1}{|l|}{BottomUpVar1}  &      &                                                           &                                                              &      &                                                        &                                                         &                                                           \\ \hline
		\multicolumn{1}{|l|}{BottomUpVar2}  &      &                                                           &                                                              &      &                                                        &                                                         &                                                           \\ \hline
		\multicolumn{1}{|l|}{SplitThenFill} &      &                                                           &                                                              &      &                                                        &                                                         &                                                           \\ \hline
		\multicolumn{1}{|l|}{SplitAndFill}  &      &                                                           &                                                              &      &                                                        &                                                         &                                                           \\ \hline
	\end{tabular}
\end{table}
\pagebreak