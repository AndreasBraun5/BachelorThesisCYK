% !TeX spellcheck = en_GB

\section{Algorithms}\label{algorithms}

\noindent Does the output $P \subseteq V \times (V^{2} \cup \Sigma)$ imply that $G$ is in CNF? CNF does only have useful variables [TI script Def. 8.3 page 210] vs. $P \subseteq V \times (V^{2} \cup \Sigma)$.\\
\noindent More of a problem is that the set $P$ is not necessarily in CNF. It is possible that there are unreachable variables -- from the starting variable.

\subsection{Algorithm sub modules}
Sub modules are parts of the algorithms that are denoted with \circled{A}, \circled{B}, ... . They are noteworthy procedures that need to be explained in more detail for a better understanding of the way of working of the algorithms.
\subsubsection{Distribute A \& B}
\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{Distribute}
		\label{Distribute}
		\SetAlgoLined
		\KwIn{ $Rhse \subseteq\ (V^{2} \cup \Sigma),\ V$}
		\KwOut{Set of productions $P$}
		$i \in  \mathbb{N},\ j \in  \mathbb{N}$\;
		\ForEach{$rhse \in Rhse$}{
			$choose\ n\ uniform\ randomly\ in\ [i, j]$\;
			$V_{add} := uniform\ random\ subset\ of\ size\ n\ from\ V$\;
			$P = P \cup \{ (v, rhse)\ |\ v \in V_{add},\ rhse \in Rhse \} $\;	
		}
		\Return $P$;
	\end{algorithm}
}
Algorithm \ref{Distribute} isn't needed anymore for the descriptions of the basic idea of the algorithm. It will be a module later on while tweaking the algorithms.

\subsubsection{Stopping Criteria C}
It is fulfilled if more than half of the pyramid cell are not empty.

\subsubsection{ChooseXYDependingOnIFromRowSet D}
$RowSet \subseteq \{(XY,i)\ |\ X,Y \in V \wedge i \in \mathbb{N} \}$\\
Compression of the RowSet like: (AB,3) and (AB,1) -> (AB,1) --> RowSetCompressed\\
rowListWeighted = add i times XY to rowListWeighted.

\pagebreak
\subsection{DiceRollOnly}
\subsubsection{Basic Idea}
\noindent This is a very naive way of generating grammars, which will be the starting point for our algorithms to be found. Each future algorithm must have a higher score than this algorithm or otherwise it would be worse, than simple dice rolling the distribution of terminals and compound variables with removing the not contributing productions afterwards.
\subsubsection{Algorithm}

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{DiceRollOnly}
		\label{DiceRollOnly}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$ }
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$P = Distribute(\Sigma,\ V)$;  \circled{A}\\
		$P = P \cup Distribute(V^2,\ V)$;  \circled{B}\\
		$Pyramid = CYK(G,\ w)$\;	
		$P = DeleteUnneccessaryRules(P, w, Pyramid)$\; \label{contributing}	
		\Return $P$\;
		\footnotetext{ 
			Line \ref{contributing}: ?Removes all production that don't contribute, but unreachable productions still possible.? $Contributing$ production iff $useful$ i.e. it appears in some derivation of some terminal string from the start symbol AND $producing$ i.e. it is needed for this parsing table.
		}
	\end{algorithm}
}
As seen in table \ref{DiceRollOnlySR} the algorithm shows a relatively low success rate for producibility.
\begin{table}[H]
\centering
	\begin{tabular}{ | l || c |c |c |c | }
	\hline
	Algorithm 		& SR 	& SRP 	& SRG 	& SRWP   	\\ \hline
	\hline
	DiceRollOnly 	& 09~\%	& 24~\% & 87~\% & 53~\%		\\ \hline
	\end{tabular}
	\caption{Success rates for algorithm \ref{DiceRollOnly}}
	\label{DiceRollOnlySR}
\end{table}
\noindent This can be explained with ... . 

\noindent Something about what can be improved in another attempt or the next attempt. 
\pagebreak


\subsection{BottomUpDiceRollVar1}
\subsubsection{Basic Idea} 
This algorithm uses the Bottom-Up approach where the parsing table is filled starting from the leaves. An extension compared to algorithm \ref{DiceRollOnly} is that productions are only added as long as the the stopping criteria isn't met.
\subsubsection{Algorithm}

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{BottomUpDiceRollVar1}
		\label{BottomUpDiceRollVar1}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$ }
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$P = Distribute(\Sigma,\ V)$;  \circled{A}\\
		$Pyramid = CYK(G,\ w)$\label{stepii}\;
		\For{$i:=1\ \textbf{to}\ i_{max}$}{
			$J = \{0,~...~,~j_{max} -1\}$;~~\tcp{$J \subseteq \mathbb{N}$}
			$CellSet = \emptyset$;~~\tcp{$CellSet \subseteq V^2$}
			\While{$|J|>0$}{
				$choose\ one\ j \in J\ uniform\ randomly$\label{chooseJ}\;
				$J = J \setminus \{j\} $\;
				$CellSet = CalculateSubsetForCell(Pyramid,\ i,\ j)$\;
				$P = P \cup Distribute(CellSet,\ V)$;  \circled{B}\\
				$Pyramid = CYK(G,\ w)$\;
				$P = DeleteUnneccessaryRules(P, w, Pyramid)$\; \label{contributing}	
				\If{$stopping\ criteria~met$~\circled{C}}{
					\Return $P$\;
				}
			}
		}
		\Return $P$\;
		\footnotetext{
			\noindent Line \ref{stepii}: Fills the i=0 row of the pyramid.
			
			\noindent Line \ref{chooseJ}: A cell is only visited only once.
			
			\noindent Note: Maybe modify algorithm to also work with the threshold.
		}
	\end{algorithm}
}


\begin{table}[H]
	\centering
	\begin{tabular}{ | l || c |c |c |c | }
	\hline
	Algorithm 		& SR 	& SRP 	& SRG 	& SRWP   	\\ \hline
	\hline
	DiceRollOnly 	& 09~\%	& 24~\% & 87~\% & 53~\%		\\ \hline
	BotomUpVar1 	& 13~\% & 29~\% & 99~\% & 68~\% 	\\ \hline
	\end{tabular}
	\caption{Success rates for algorithm \ref{BottomUpDiceRollVar1}}
	\label{BottomUpDiceRollVar1SR}
\end{table}


A relatively small number of productions is already sufficient to completely fill the parsing table. This can be seen if one does take look at the log-file where the final cell that has been worked with is denoted.
A good chosen stopping criteria allows a higher success rate.

\pagebreak
\subsection{BottomUpDiceRollVar2}
\subsubsection{Basic Idea} 
As seen in algorithm \ref{BottomUpDiceRollVar1} a small number of productions is sufficient to make the parsing table quite full. If an cell is nearer to the leaves its chance to be in the set of one of the calculated sub sets for a cell is higher. Therefore you could introduce a bias that favours cells with an higher index i to allow different cell combinations.

\subsubsection{Algorithm}

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{BottomUpDiceRollVar2}
		\label{BottomUpDiceRollVar2}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$ }
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$RowSet = \emptyset$;~~\tcp{$RowSet \subseteq \{(XY,i)\ |\ X,Y \in V \wedge i \in \mathbb{N} \}$}
		$P = Distribute(\Sigma,\ V)$;  \circled{A}\\
		$Pyramid = CYK(G,\ w)$ \label{stepii}\;
		\For{$i:=1\ \textbf{to}\ i_{max}$}{
			%$choose\ j\ uniform\ randomly\ in\ [0,\ j_{max}-i]  $\;
			\For{$j:=0\ \textbf{to}\ j_{max}-i$}{
				$RowSet = RowSet \cup \{(XY,i)\ |\ XY \in CalculateSubsetForCell(Pyramid,\ i,\ j) \}$\label{rowSet}\;
			}
			\While{$threshold_i\ not\ reached $}{ \label{threshold}
				$choose\ one~xy\ out\ of\ (XY,\ i) \in RowSet~uniform\ randomly\ with$ $probability~depending~on~i $;\label{chooseVc} \circled{D}  \\
				$P = P \cup Distribute(xy,\ V) $; \circled{B}  \\
				$Pyramid = CYK(G,\ w)$\;
				$P = DeleteUnneccessaryRules(P, w, Pyramid)$\; \label{contributing}	
				\If{$stopping\ criteria~met$~\circled{C}}{
					\Return $P$\;
				}	
			}
		}
		\Return $P$\;
		\footnotetext{
			\noindent Line \ref{stepii}: Fills the i=0 row of the pyramid.
			
			\noindent Line \ref{rowSet}: $(AB,1), (AB,2), (BC,3) ... \in sub$ $\rightarrow$ multiple occurrences of $AB$ are allowed here yet.
			
			\noindent Note Line \ref{threshold}: threshold is reached iff more than half of the cells of one row aren't empty.
		}
	\end{algorithm}
}


\begin{table}[H]
	\centering
	\begin{tabular}{ | l || c |c |c |c | }
	\hline
	Algorithm 		& SR 	& SRP 	& SRG 	& SRWP   	\\ \hline
	\hline
	DiceRollOnly 	& 09~\%	& 24~\% & 87~\% & 53~\%		\\ \hline
	BotomUpVar1 	& 13~\% & 29~\% & 99~\% & 68~\% 	\\ \hline
	BotomUpVar2 	& 16~\% & 26~\% & 99~\% & 77~\% 	\\ \hline
	\end{tabular}
	\caption{Success rates for algorithm \ref{BottomUpDiceRollVar2}}
	\label{BottomUpDiceRollVar2SR}
\end{table}

\pagebreak
\subsection{SplitThenFill (Idea 1)}
\subsubsection{Basic Idea} 
The basic idea for this algorithm is to uniform randomly generate a predefined structure of the derivation tree that helps adding the "right" productions. You always update the pyramid after adding one production to the grammar.
This is also some kind of BottumUp approach - Bottom Up: The parse table is filled relatively evenly. All information regarding the upper cells are available and can be used. Similar to the CYK Algorithm approach.
\subsubsection{Algorithm}
\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{SplitThenFillPrep}
		\label{SplitThenFillPrep}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$}
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$P = Distribute(\Sigma,\ V)$; \circled{A} \label{stepii}  \\		
		$Sol = (P_{Sol},~Cell_{i,j})$;~~\tcp{$P_{Sol} \subseteq P~\wedge~ Cell_{i,j} \in Pyramid$} \label{cell}
		$Sol = SplitThenFill(P,\ w,\ i_{max},\ 0)$\;
		\Return $P_{Sol}$\;
		\footnotetext{
			\noindent Line \ref{stepii}: Fills the i=0 row of the pyramid.	
		}
	\end{algorithm}
}
\\

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{SplitThenFill}
		\label{SplitThenFill}
		\SetAlgoLined
		\KwIn{$P \subseteq V \times (V^{2} \cup \Sigma),\ w \in \Sigma^{*},\ i,j \in \mathbb{N}$ }
		\KwOut{$(P,~Cell_{i,j})$}
		\If{$i=0$}{
			\Return $(P,\ Cell_{i,j})$\label{row0}\;
		}	
		$choose\ one\ m\ uniform\ randomly\ in\ [j+1,\ j+i]$\;
		$(P,\ Cell_l) = SplitThenFill(P,\ w,\ (m-j-1),\ j)$\label{left}\;
		$(P,\ Cell_r) = SplitThenFill(P,\ w,\ (j+i-m),\ m)$\label{right}\;
		$Pyramid = CYK(G,\ w)$\label{cyk}\;
		\If{$stopping\ criteria~met$~\circled{C}}{
			\Return $(P,\ Cell_{i,j})$\;
		}
		\If{$Cell_{i,j} = \emptyset$}{
			$Vc = uniform\ random\ subset\ from\ \{vc\ |\ v \in Cell_l\ \wedge\ c \in Cell_r\} ~with~|Vc| \geq 1$\;
			$P = P \cup Distribute(Vc,\ V) $; \circled{B}  \\
		}
		
		\Return $(P,\ Cell_{i,j})$\;
		\footnotetext{
		}
	\end{algorithm}
}
\\
\begin{table}[H]
	\centering
	\begin{tabular}{ | l || c |c |c |c | }
		\hline
		Algorithm 		& SR 	& SRP 	& SRG 	& SRWP   	\\ \hline
		\hline
		DiceRollOnly 	& 09~\%	& 24~\% & 87~\% & 53~\%		\\ \hline
		BotomUpVar1 	& 13~\% & 29~\% & 99~\% & 68~\% 	\\ \hline
		BotomUpVar2 	& 16~\% & 26~\% & 99~\% & 77~\% 	\\ \hline
		SplitThenFill 	& 20~\% & 62~\% & 81~\% & 45~\% 	\\ \hline
	\end{tabular}
	\caption{Success rates for algorithm \ref{SplitThenFill}}
	\label{SplitThenFillSR}
\end{table}
\noindent The stopping criteria is met if the tip of the pyramid is not empty. It is a valid approach because if this cell is not empty it means that there is a chance of being able to generate the word. To add further productions only results in a grammar that has to many productions with its pyramid having to many variables.
\pagebreak

\subsection{SplitAndFill}
\subsubsection{Basic Idea} 
Now there is a second option to fill the parse table:
\begin{enumerate}
	\item Top Down: The parse table is filled quiet unevenly. You don't have all information available. Think about adding a production for the node cell: You can add a production so that its producing cells fill the node cell, but you don't know what actually would be the best to fill in these producing cells because they themselves aren't looked at yet. This problem is kept until the last depth of the recursion, where the cells in row $i=0$ are taken into account. Only starting there you know what variables actually produce the terminals.\\
	Maybe solution: For the Top Down approach, don't assume that the terminals are already distributed over the V. Distribute the terminals over the variables in an ideal way that fits your already generated productions best.
\end{enumerate}
\subsubsection{Algorithm}
\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{SplitAndFillPrep}
		\label{SplitAndFillPrep}
		\SetAlgoLined
		\KwIn{Word $w \in \Sigma^{*}$}
		\KwOut{Set of productions $P$}
		$P = \emptyset$;~~\tcp{$P \subseteq V \times (V^{2} \cup \Sigma)$}
		$Pyr = EmptyPyramid$ \label{emptyPyramid}\;
		$Cell_{i_{max},0} = Cell_{i_{max},0} \cup \{S\}$;~~\tcp{$Cell_{i,j} \subseteq V \wedge Cell_{i,j} \in Pyramid$} \label{cell}
		\;
		$Sol = \emptyset$;~~\tcp{$Sol \subseteq \{(P_{Sol},~Pyramid)~|~P_{Sol} \subseteq P$\}} \label{cell}	
		$Sol = SplitThenFill(Pyr,\ P,\ w,\ i_{max},\ 0)$\;
		$P = P \cup P_{Sol}$\; \label{tip}
		\Return $P$\;
		\footnotetext{
			\noindent Line \ref{emptyPyramid}: $EmptyPyramid \Leftrightarrow \forall i\ \forall j\ Cell_{i,j}=\emptyset$
			
			\noindent Line \ref{cell}: $Cell_{i,j} \subseteq V \wedge Cell_{i,j} \in Pyramid$. The pyramid represents the upper part of the upper triangular matrix of the CYK. Reflection at the diagonal of the matrix and rotation of -45 degrees.
		}
	\end{algorithm}
}
\\

\noindent
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{SplitAndFill}
		\label{SplitAndFill}
		\SetAlgoLined
		\KwIn{$Pyramid~Pyr,\ P \subseteq V \times (V^{2} \cup \Sigma),\ w \in \Sigma^{*},\ i,j \in \mathbb{N}$ }
		\KwOut{$(P,~Pyr)$}
		\If{$stopping\ criteria~met$~\circled{C}}{
			\Return $(P,\ Pyr)$\;
		}
		$SetAll = V \times V$\;
		$Pyramid = CYK(G,\ w)$\label{cyk}\;
		$choose\ one\ m\ uniform\ randomly\ in\ [j+1,\ j+i]$\;
		
		\If{$(m-j-i) \neq 0$}{
			$(P,\ Pyr) = SplitAndFill(Pyr,\ w,\ (m-j-1),\ j)$\label{left}\;	
		} else then\\
			~~~~~~$v = choose~one~variable~uniform~randomly~from~Cell_{i,j}$\;
			~~~~~~$P = P \cup (v --> w_j)$\;
		end
		
		\If{$(j+i-m) \neq 0$}{
			$(P,\ Pyr) = SplitAndFill(Pyr,\ w,\ (j+i-m),\ m)$\label{right}\;
		} else then\\
			~~~~~~$v = choose~one~variable~uniform~randomly~from~Cell_{i,j}$\;
			~~~~~~$P = P \cup (v --> w_j)$\;
		end
		\Return $(P,\ Cell_{i,j})$\;
		\footnotetext{
		}
	\end{algorithm}
}

\pagebreak
\subsection{Comparision of Algorithms}

\begin{table}[H]
	\centering
	\begin{tabular}{ | l | c |c |c |c | }
		\hline
Algorithm 		& SR 	& SRP 	& SRG 	& SRWP   	\\ \hline
\hline
DiceRollOnly 	& 09~\%	& 24~\% & 87~\% & 53~\%		\\ \hline
BotomUpVar1 	& 13~\% & 29~\% & 99~\% & 68~\% 	\\ \hline
BotomUpVar2 	& 16~\% & 26~\% & 99~\% & 77~\% 	\\ \hline
BotomUpVar2 	& 20~\% & 62~\% & 81~\% & 45~\% 	\\ \hline
	\end{tabular}
	\caption{Comparison of the success rates of the algorithms}
	\label{comparisonAlgorithms}
\end{table}

\pagebreak