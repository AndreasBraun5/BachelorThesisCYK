% !TeX spellcheck = en_GB

\section{Introduction}\label{Introduction}

\subsection{Motivation}

The starting point of this thesis is to get a tool to automatically generate a suitable 4-tuple $exercise = (grammar,\ word,\ parse\ table,\ derivation\ tree)$, that is used to test if the students have understood the way of working of the CYK algorithm.\\
Various implementations of the Cocke-Younger-Kasami (CYK) algorithm can be found [XXX]. Nevertheless it is required to automatically generate suitable $exercise$s, that afterwards can be modified as wanted. This is the reason an own implementation has been made. It is also a task to find a more clever algorithm to automatically generate $exercise$s with a high chance of being suitable as an exam exercise.

\subsection{Context Free Grammar in Chromsky Normal Form}
\begin{DefGrey} \textbf{Context Free Grammar (CFG)}\\
	We define a CFG as the 4-tuple $G=(V,\ \Sigma,\ S,\ P)$:
	\begin{itemize}
		\item $V$ is a finite set of variables.
		\item $\Sigma$ is an alphabet
		\item $S$ is the start symbol and $S \in V$.
		\item $P$ is a finite set of rules: $P \subseteq V \times (V \cup \Sigma)^{*}$.
	\end{itemize}
	It is valid that $\Sigma \cap V =  \emptyset$.
\end{DefGrey}
\begin{DefGrey}\label{CFGinCNF} \textbf{CFG in Chromsky Normal Form (CNF)}\\
	A CFG $G=(V,\ \Sigma,\ S,\ P)$ is in CNF iff.:
	\begin{itemize}
		\item $P \subseteq V \times (V \cup \Sigma)^{*}$.
	\end{itemize}
\end{DefGrey}
\noindent Regarding this thesis a grammar is always synonymous with Definition \ref{CFGinCNF}. For further convenience the following default values are always true:
\begin{itemize}
	\item $V = \{A, B, ...\}$
	\item $(V^2 \cup\ \Sigma)^{*}=\{a, b, ...\} \cup \{AA, AB, BB, BA, BS, AC, ... \}$
\end{itemize}
\begin{DefGrey}\label{wordLanguage} \textbf{Word $w$ and language $L(G)$}\\
	Word $w$ and language $L(G)$:
	\begin{itemize}
		\item $w \in \Sigma^* = \{w_0,~w_1,~...,~w_j\}$.
		\item A language $L(G)$ over an alphabet $\Sigma$ is a set of words over $\Sigma$ .
	\end{itemize}
\end{DefGrey}
\noindent Moreover in the context of talking about sets, a set is always described beginning with an upper case letter, while one specific element of a set is described beginning with a lower case letter. Example: A "$Pyramid$" is a set consisting of multiple "$Cell$"s, whereas a $Cell$ is again a subset of the set of variables "$V$". A "$cellElement$" is one specific element of a "$Cell$". (For further reasoning behind this example see chapter XXX "help data structure") 
\subsection{General approaches}
Two basic approaches, that may help finding a good algorithm are explained informally.
\subsubsection{Forward Problem \& Backward Problem}
The Forward Problem and the Backward Problem are two ways as how to determine if $w \in L(G)$.	
\begin{DefGrey}
	\textbf{Forward Problem ($G \xrightarrow[]{derivation} w$)} \\
	Input: Grammar $G$ in CNF. \\
	Output: Derivation $d$ that shows implicitly $w \subseteq L$.
\end{DefGrey}
\noindent It is called Forward Problem, if you are given a grammar $G$ and form a derivation from its root node to a final word $w$. The final word $w$ is always element of $L(G)$.
\begin{DefGrey}
	\textbf{Backward Problem = Parsing ($w\overset{?}{\subseteq}L(G)$)}\\
	Input: $w$ and a grammar $G$ in CNF. \\
	Output: $w \subseteq L(G) \Longrightarrow$ derivation $d$.
\end{DefGrey}
\noindent If you are given a word $w$ and want to determine if it is element of $L(G)$, it is called Backward Problem or parsing.
\subsubsection{Parsing Bottom-Up \& Top-Down}
There are again two ways to classify the approach of parsing.
\begin{DefGrey}
	\textbf{Bottom-Up parsing} \\
	 Bottom-Up parsing means to start parsing from the leaves up to the root node.
\end{DefGrey}
\noindent "Bottom-Up parsing is the general method used in the Cocke-Younger-Kasami(CYK) algorithm, which fills a parse table from the "bottom up""[Duda 8.6.3 page 426].
\begin{DefGrey}
	\textbf{Top-Down parsing} \\
	 Top-Down parsing means to start parsing from the node down to the leaves.
\end{DefGrey}
\noindent "Top-Down parsing starts with the root node and successively applies productions from $P$, with the goal of finding a derivation of the test sentence $w$." [XXX] (The so called test sentence is synonymous to an word $w$.)
Reasonably criteria to guide the choice of which rewrite rule to apply could include to begin the parsing at the first (left) or last (right) character of the word $w$ [XXX][Duda 8.6.3 page 428]

\subsection{Data Structure Pyramid}
To be able to describe the way of working of the different algorithms easier the help data structure $Pyramid$ will be defined \textendash~note that $Pyramid$ starts with upper case and therefore is a set). But before that:
\begin{DefGrey} \textbf{$[i, j]$} \\
	$[i,\ j] := \{i,\ i+1,..., j-1,\ j\} \subseteq \mathbb{N}_{\geq 0}$.
\end{DefGrey}

\begin{DefGrey} \textbf{$Cell_{i,j}$} \\
	$Cell_{i,j} \subseteq \{(V,k)~|~k \in \mathbb{N} \}$
\end{DefGrey}
\noindent Now $Pyramid$ can be defined as following:
\begin{DefGrey} \textbf{$Pyramid$} \\
	$Pyramid :=\{ Cell_{i,j}\ |\ i \in [0,\ i_{max}],\  j \in [0,\ j_{max,i}],\ i_{max} = |w|-1,~j_{max,i} = i_{max} -i\}$.
\end{DefGrey}
\noindent The following is the visual representation of a $Pyramid$ that additionally has written the word $w$ above it:
\newcommand{\boxpyramid}[1]{
	\fontsize{5}{12}\selectfont{#1}
}
\begin{figure}[H]
\centering
	\resizebox{\linewidth}{!}{
		\begin{tikzpicture}[baseline]
		\newcommand{\myfontvars}[1]{
			\fontsize{4.9}{12}\selectfont{#1}
		}\newcommand{\myfontnumbering}[1]{
			\fontsize{2.5}{12}\selectfont{#1}
		}%Outer hull
		%Tip of the pyramid
		\coordinate (tip) at (3,-3);
		\foreach \i in {0,...,6} {
			\coordinate (\i) at (\i,0);
		}
		%\draw[help lines] (-1,1) grid (6,-3);
		\draw [->, thick] (-0.5,1) -- (0.5,1);
		\node [above] at (0, 1) {j};
		\draw [->, thick] (-0.5,1) -- (-0.5,-0.0);
		\node [left] at (-0.5,0.5) {i};
		%Draw the left and right line of the pyramid pointing downwards
		\draw (0) -- (tip) -- (6);
		%Grid lines direction down-left to top-right
		\coordinate (dl1) at (0.5,-0.5);
		\coordinate (dl2) at (1.0,-1.0);
		\coordinate (dl3) at (1.5,-1.5);
		\coordinate (dl4) at (2.0,-2.0);
		\coordinate (dl5) at (2.5,-2.5);
		\draw (dl1) -- (1,0);
		\draw (dl2) -- (2,0);
		\draw (dl3) -- (3,0);
		\draw (dl4) -- (4,0);
		\draw (dl5) -- (5,0);
		%Grid lines direction down-right to top-left
		\coordinate (dr1) at (3.5,-2.5);
		\coordinate (dr2) at (4.0,-2.0);
		\coordinate (dr3) at (4.5,-1.5);
		\coordinate (dr4) at (5.0,-1.0);
		\coordinate (dr5) at (5.5,-0.5);
		\draw (dr1) -- (1,0);
		\draw (dr2) -- (2,0);
		\draw (dr3) -- (3,0);
		\draw (dr4) -- (4,0);
		\draw (dr5) -- (5,0);
		%Small lines at the top
		\coordinate (top0) at (0.0,0.0);
		\coordinate (top1) at (1.0,0.0);
		\coordinate (top2) at (2.0,0.0);
		\coordinate (top3) at (3.0,0.0);
		\coordinate (top4) at (4.0,0.0);
		\coordinate (top5) at (5.0,0.0);
		\coordinate (top6) at (6.0,0.0);
		\coordinate (topUpper0) at (0.0,0.6);
		\coordinate (topUpper1) at (1.0,0.6);
		\coordinate (topUpper2) at (2.0,0.6);
		\coordinate (topUpper3) at (3.0,0.6);
		\coordinate (topUpper4) at (4.0,0.6);
		\coordinate (topUpper5) at (5.0,0.6);
		\coordinate (topUpper6) at (6.0,0.6);
		\draw (top0) -- (topUpper0);
		\draw (top1) -- (topUpper1);
		\draw (top2) -- (topUpper2);
		\draw (top3) -- (topUpper3);
		\draw (top4) -- (topUpper4);
		\draw (top5) -- (topUpper5);
		\draw (top6) -- (topUpper6);
		%The string
		\coordinate (w0) at (0.5,0.6);
		\coordinate (w1) at (1.5,0.6);
		\coordinate (w2) at (2.5,0.6);
		\coordinate (w3) at (3.5,0.6);
		\coordinate (w4) at (4.5,0.6);
		\coordinate (w5) at (5.5,0.6);
		\node [] at (w0) {$w_0$};
		\node [] at (w1) {$w_1$};
		\node [] at (w2) {$w_2$};
		\node [] at (w3) {$w_3$};
		\node [] at (w4) {$w_4$};
		\node [] at (w5) {$w_5$};
		% Variables in the cells
		%cell00
		\coordinate (center00) at (0.5,0.0);
		\node [below=0.18cm] at (center00) {\myfontnumbering{$(00)$}};
		%cell01
		\coordinate (center01) at (1.5,0.0);
		\node [below=0.18cm] at (center01) {\myfontnumbering{$(01)$}};
		%cell02
		\coordinate (center02) at (2.5,0.0);
		\node [below=0.18cm] at (center02) {\myfontnumbering{$(02)$}};
		%cell03
		\coordinate (center03) at (3.5,0.0);
		\node [below=0.18cm] at (center03) {\myfontnumbering{$(03)$}};
		%cell04
		\coordinate (center04) at (4.5,0.0);
		\node [below=0.18cm] at (center04) {\myfontnumbering{$(04)$}};
		%cell05
		\coordinate (center05) at (5.5,0.0);
		\node [below=0.18cm] at (center05) {\myfontnumbering{$(05)$}};
		%cell10
		\coordinate (center10) at (1.0,-0.5);
		\node [below=0.18cm] at (center10) {\myfontnumbering{$(10)$}};
		%cell11
		\coordinate (center11) at (2.0,-0.5);
		\node [below=0.18cm] at (center11) {\myfontnumbering{$(11)$}};
		%cell12
		\coordinate (center12) at (3.0,-0.5);
		\node [below=0.18cm] at (center12) {\myfontnumbering{$(12)$}};
		%cell13
		\coordinate (center13) at (4.0,-0.5);
		\node [below=0.18cm] at (center13) {\myfontnumbering{$(13)$}};
		%cell14
		\coordinate (center14) at (5.0,-0.5);
		\node [below=0.18cm] at (center14) {\myfontnumbering{$(14)$}};
		%cell20
		\coordinate (center20) at (1.5,-1.0);
		\node [below=0.18cm] at (center20) {\myfontnumbering{$(20)$}};
		%cell21
		\coordinate (center21) at (2.5,-1.0);
		\node [below=0.18cm] at (center21) {\myfontnumbering{$(21)$}};
		%cell22
		\coordinate (center22) at (3.5,-1.0);
		\node [below=0.18cm] at (center22) {\myfontnumbering{$(22)$}};
		%cell23
		\coordinate (center23) at (4.5,-1.0);
		\node [below=0.18cm] at (center23) {\myfontnumbering{$(23)$}};
		%cell30
		\coordinate (center30) at (2.0,-1.5);
		\node [below=0.18cm] at (center30) {\myfontnumbering{$(30)$}};
		%cell31
		\coordinate (center31) at (3.0,-1.5);
		\node [below=0.18cm] at (center31) {\myfontnumbering{$(31)$}};
		%cell32
		\coordinate (center32) at (4.0,-1.5);
		\node [below=0.18cm] at (center32) {\myfontnumbering{$(32)$}};
		%cell40
		\coordinate (center40) at (2.5,-2.0);
		\node [below=0.18cm] at (center40) {\myfontnumbering{$(40)$}};
		%cell41
		\coordinate (center41) at (3.5,-2.0);
		\node [below=0.18cm] at (center41) {\myfontnumbering{$(41)$}};
		%cell50
		\coordinate (center50) at (3.0,-2.5);
		\node [below=0.18cm] at (center50) {\myfontnumbering{$(50)$}};
		\end{tikzpicture}
	}
\caption{Visual representation of a $Pyramid$ with the word $w$ above it.}
\end{figure}
\begin{DefGrey} \textbf{$CellDown,~CellUpperLeft~and~CellUpperRight$} \\
	Let there be a $Cell_{i,j}$ then the following is true:
	\begin{itemize}
		\item $CellDown = Cell_{i,j}$.
		\item $CellUpperLeft = Cell_{i-1,j}$.
		\item $CellUpperRight = Cell_{i-1,j+1}$.
	\end{itemize}
\end{DefGrey}
\subsection{ Cocke-Younger-Kasami Algorithm}
The Cocke-Younger-Kasami Algorithm (CYK) has been developed independently in the 1960s by Itiroo Sakai, John Cocke, Tadao Kasami, Jacob Schwartz and Daniel Younger that uses the principle of dynamic programming. [XXX]\\
The description of the algorithm follows [TI Hofmann] adjusted to the help data structure $Pyramid$. \\

\noindent \frame{
	\begin{algorithm}[H] %or another one check
		\caption{CYK}
		\label{CYK}
		\SetAlgoLined
		\KwIn{Grammar $G=(V,\ \Sigma,\ S,\ P)$ and word $w \in \Sigma^* = \{w_0,~w_1,~...,~w_j\}$ }
		\KwOut{true $\Leftrightarrow w\in L(G)$}
		$Pyramid = \emptyset $\;
		\For{$j:=0 \to i_{max}$}{ \label{row1}
			$Pyramid \cup Cell_{0,j} = \{(X,j)~|~X \longrightarrow w_j\}$
		}
		\For{$i:=1 \to i_{max}$}{ \label{rows}
			\For{$j:=0 \to j_{max,i}$}{ \label{eachCell}
				\For{$k:=i-1 \to 0$}{ \label{cellCombs}
					$Pyramid \cup Cell_{i,j} =  \{X\ |\ X\longrightarrow YZ,\ Y \in Cell_{k,j},\ Z \in Cell_{i-k-1,k+j+1} \}$\;
				}
			}
		}
		$wInL = false$\;
		\If{$(S,i) \in Cell_{i_{max},0}$}{
			$wInL = true$\; \label{true}
		}
		\Return $wInL$;
		\footnotetext{ 
		Line \ref{row1}: First row.\\
		Line \ref{rows}: All rows except the first. \\
		Line \ref{eachCell}: All cells in each row. \\
		Line \ref{cellCombs}: All possible cell combinations for each cell. \\
		Line \ref{true}: True iff $Cell_{i_{max},0}$ contains the start variable.
		}
	\end{algorithm}
}


\subsection{Success Rates}
\noindent Success Rates ($SR$) are used to compare the algorithms accounting to their performance of the different requirements. Let $N \in  \mathbb{N}$ be the overall count of all generated grammars of the examined algorithm.\\

\noindent Write down if the cellsVar or the cellsVarK are used.\\
Mention the basic connection between the success rates.\\



\noindent\textbf{Overall Success Rate}
An generated $exercise$ contributes to the Overall Success Rate ($SR$) iff it contributes to the Success Rate Producibility ($SRP$), to the Success Rate Grammar Constraints ($SRG$) and to the Success Rate Pyramid Word Constraints ($SRPW$) at the same time.\\
It holds: $SR = n / N$, whereas $n$ is the count of $exercises$ that fulfil the requirements in this case.\\

\noindent\textbf{Success Rate Producibility}
An generated $exercise$ contributes to the $SRP$ iff the CYK algorithm's output is true.\\
It holds: $SRP = p / N$, whereas $p$ is the count of $exercises$ that fulfil the requirements in this case.\\

\noindent\textbf{Success Rate Grammar Constraints}
An generated $exercise$ contributes to the $SRG$ iff the following conditions are met:
\begin{itemize}
	\item grammar has got less than a certain amount of productions.
\end{itemize}
It holds: $SRG = g / N$, whereas $g$ is the count of $exercises$ that fulfil the requirements in this case.\\

\noindent\textbf{Success Rate Word Pyramid Constraints}
An generated $exercise$ contributes to the $SRWP$ iff the following conditions are met:
\begin{itemize}
	\item A certain amount of cells force a right cell combination.
	\item There are less than a certain amount of variables in the entire pyramid.
	\item There are less than a certain amount of variables in each cell of the pyramid.
\end{itemize}
It holds: $SRWP = wp / N$, whereas $wp$ is the count of $exercises$ that fulfil the requirements in this case.
\pagebreak

\noindent Fore more detail of fore right cell combination see here:\\

\noindent 
\frame{
	\begin{algorithm}[H] %or another one check
		\caption{checkForceCombinationPerCell}
		\label{checkRightCellPerCombination}
		\SetAlgoLined
		\KwIn{$ CellDown\subseteq V,\ CellUpperLeft\subseteq V,\ CellUpperRight \subseteq V,\ P \subseteq V \times (V^{2} \cup \Sigma) $ }
		\KwOut{$true \iff at~least~one~variable~forces$}
		$VarsForcing \subseteq V$\;
		$VarComp = \{xy\ |\ x \in CellUpperLeft\ \wedge\ y \in CellUpperRight \}$\;
		\ForEach{$v \in CellDown$}{
			$Prods = \{p\ |\ p \in P\ \wedge\ p=(v_1,rhse_1)\ \wedge\ v==v_1 \}$\;
			$Rhses = \{rhse\ |\ p \in Prods\ \wedge\ p=(v_1,rhse_1)\ \wedge\ rhse==rhse_1\} $\;
			\If{$Rhses \nsubseteq VarComp$}{
				$VarsForcing = VarsForcing \cup v$\;
			}			
		}
		\Return $|VarsForcing| > 0$\;
		\footnotetext{
		}
	\end{algorithm}
}


\pagebreak